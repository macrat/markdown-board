---
name: prioritize-issues
description: GitHub Issueの対応優先順位を決定するスキル。全面的なリファクタリングを最優先し、手戻りと競合の最小化を原則として一貫した優先順位付けを行う。
user_invocable: true
---

# Issue優先順位決定スキル

このスキルは、オープンなGitHub Issueの対応優先順位を決定するワークフローです。一貫した基準で優先順位を付けることで、手戻りや競合を最小化し、全体の作業効率を高めます。

以下のステップを**必ず順番通りに**実行してください。

---

## 基本原則

優先順位を決定する際、以下の2つの原則を常に意識してください。これらはティア分類よりも上位の判断基準です。

1. **手戻りと競合の最小化**: 先に着手すべき作業を後回しにすると、他のIssueで手戻りやマージコンフリクトが発生する。これを防ぐ順序を選ぶ
2. **全体の作業量の最小化**: 同じ成果を得るために、最も少ない総作業量で済む順序を選ぶ

ティア分類と上記の原則が矛盾する場合は、**原則を優先**してください。

---

## ステップ1: オープンなIssueを取得する

Bashツールで以下を実行し、オープンなIssueの一覧を取得してください:

```bash
gh issue list --state open --limit 100 --json number,title,labels,body,createdAt
```

取得したIssueの件数が0件の場合は、「オープンなIssueはありません」と報告して終了してください。

---

## ステップ2: 各Issueの内容を分析する

Taskツール（`subagent_type=Explore`）を起動し、各Issueに関連するコードの影響範囲を調査してください。

以下のプロンプトでExploreエージェントを起動してください:

> 以下のGitHub Issueの一覧について、各Issueが影響するファイルや領域を調査してください。
>
> 【Issueの一覧をここに記載】
>
> 各Issueについて以下を報告してください:
>
> - **Issue番号とタイトル**
> - **変更対象の推定**: どのファイルやディレクトリに変更が必要か
> - **影響範囲**: 変更が波及しうる他のファイルやコンポーネント
> - **他のIssueとの依存関係**: 先に完了すべきIssue、または同時に変更すると競合しやすいIssueがあるか
> - **変更の性質**: 以下のどれに該当するか
>   - 全面的なリファクタリングや構造の変更
>   - 部分的なリファクタリング
>   - ドキュメントの改善
>   - バグ修正
>   - テストの追加・改善
>   - 新機能の追加
>   - その他

---

## ステップ3: ティア分類を行う

ステップ2の分析結果をもとに、各Issueを以下の3つのティアに分類してください。

### ティア1（最優先）: 全面的なリファクタリングや構造の変更

**対象**: コードベース全体またはアーキテクチャに影響する大規模なリファクタリングや構造変更。

**最優先にする理由**: これらの変更を後回しにすると、他のIssueの実装が旧構造に基づいて行われ、リファクタリング時に大規模な手戻りや複雑なマージコンフリクトが発生する。

**判断基準**:

- 複数のディレクトリやモジュールにまたがる構造変更
- ファイルの移動や分割・統合を伴う変更
- 共通インターフェースや型定義の変更
- ビルド設定やプロジェクト構成の変更

### ティア2: コードベースの整備

**対象**: 部分的なリファクタリング、ドキュメントの改善、バグ修正、テストの追加・改善。

**ティア1の次にする理由**: コードの整備を先に行うことで、後続のIssue対応がスムーズになる。バグ修正はコードの正しい挙動を確立し、リファクタリングはコードの見通しを良くし、テストの追加は変更の安全性を高める。

**判断基準**:

- 特定ファイルやモジュール内のリファクタリング
- ドキュメントの追加・修正
- 既知のバグの修正
- テストカバレッジの向上

### ティア3: その他の作業

**対象**: ティア1・2に該当しない作業（新機能の追加など）。

**後にする理由**: ティア1・2の完了後に着手することで、整備されたコードベースの上に新機能を構築でき、手戻りが少なくなる。

**ティア3内の順序付け**: 以下の基準で順序を決定してください:

1. **Issue間の依存関係**: 他のIssueの前提となる作業を先にする
2. **競合の回避**: 同じファイルを変更するIssueが複数ある場合、競合しにくい順序を選ぶ

---

## ステップ4: ティア内の順序を決定する

各ティア内で、以下の基準に従って具体的な実施順序を決定してください。

### 順序決定の基準

1. **依存関係**: 他のIssueが依存しているIssueを先にする
2. **影響範囲の広さ**: より多くのファイル・コンポーネントに影響するIssueを先にする（後続の作業への影響を早期に確定させる）
3. **競合リスク**: 同じファイルを変更するIssueが複数ある場合、最も多くの他Issueと競合しうるものを先にする

### 原則による調整

ティア分類と順序を決定した後、基本原則に照らして最終調整を行ってください:

- **手戻りと競合の最小化**: あるIssueを先に実施することで、他のIssueの作業がやり直しになる場合、ティアをまたいでも順序を入れ替える
- **全体の作業量の最小化**: あるIssueの成果が他のIssueの作業量を大幅に減らす場合、そのIssueの優先度を上げる

調整を行った場合は、その理由を明記してください。

---

## ステップ5: 結果を出力する

以下の形式で、依存関係のフローチャートとして結果を出力してください。

- `A ──→ B` は「AがBの前提（BはAに依存する）」を意味する
- 依存元のIssueをツリーのルートに置き、依存先を子として `├──→` や `└──→` でぶら下げる
- 依存チェーンが深い場合は `│` で縦線をつないでネストする
- どのIssueにも依存しない独立したIssueは「独立」グループにまとめる
- 各Issueには `#番号（短い説明 / 依存理由）` を記載する

````
```
## Issue依存関係

凡例: A ──→ B は「Aを先に完了すべき（BはAに依存）」

#XX（大規模リファクタリング）
  ├──→ #XX（機能A / リファクタ後の構造に依存）
  │      ├──→ #XX（機能B / 機能Aの基盤を利用）
  │      └──→ #XX（機能C / 機能Aの基盤を利用）
  └──→ #XX（機能D / リファクタ後のDB構造に依存）

#XX（バグ修正A）
  └──→ #XX（テスト追加 / 修正後のロジックをテスト）

独立（他のIssueとの依存なし）
  ├── #XX（改善A）
  ├── #XX（改善B）
  └── #XX（改善C）

### 原則による調整

[ティア分類や順序を原則に基づいて調整した場合、その内容と理由を記載。
  調整がない場合は「なし」]
```
````
